/**
 * 摊还分析
 * 数据结构一个操作序列的平均时间
 */

/**
 * 聚合分析
 *
 * multipop(S, k) 最坏的情况是每次都清空栈S 复杂度是O(n) n个操作是O(n ** 2) 这是一个上届 但是这个是不符合实际情况的
 * 对一个栈执行pop push mutipop的代价最多是O(n) 因为插入和删除是相互作用的 => average O(n) / n => O(1)
 */

/**
 * 计数器
 * 
 * 单次最坏的情况是O(n) 执行n次 => O(n ** 2) (不紧确的解)
 * 每次i为被翻1的概率是1/2
 * k-1
 * Σ   = ceil(n/2 ** i) <=  2n
 * i=0
 */
function increment(A: number[]) {
  let i = 0;
  while (i < A.length && A[i] === 1) {
    A[i] = 0;
    i = i + 1;
  }
  if (i < A.length) {
    A[i] = 1;
  }
}

/**
 * 核算法
 * 某些操作会给与信用额度 某些操作会使用信用额度 实际的摊还代价是要大于等于虚拟的摊还代价
 */

/**
 * 势能法
 */


/**
 * 动态表
 * 
 * 当表满是每次将表扩大两倍
 * n个插入总代价 Σci(i=1, m) <= n + Σ(j=0, ceil(lgn)) 2 ** j < n + 2n = 3n
 * 
 * 缩小表的时候 每次减去1/2时候并不能平均摊还时间为O(1)
 */
